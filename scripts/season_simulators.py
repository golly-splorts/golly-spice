# Instead of HellmouthGOL, use HellmouthGOL_Instrumented

class BaseSpiceManager(object):

    CupDataClass = CupBase

    def __init__(
        inputdir,
        outputdir,
        season0
    ):
        if not os.path.isdir(inputdir):
            raise Exception(f"Error: specified input dir {inputdir} does not exist")
        if not os.path.isdir(outputdir):
            raise Exception(f"Error: specified output dir {outputdir} does not exist")

        self.inputdir = inputdir
        self.outputdir = outputdir
        self.season0 = season0

        # have to load the season into self.season


    def season_map(self, threadpoolsize=2):
        """
        Perform the map step of the season generation map-reduce.

        Games are generated by separate threads,
        which write to a file in tmpdir (named gameid.json)
        with the outcome when they are complete.

        Start by creating a list of all game ids,
        and figure out which games have been completed.
        Create a thread queue and add the remaining games.

        If all games are complete, does nothing.
        """
        all_games = {}
        # have to change from schedule to season,
        # whatever other changes. i dunno.
        for day in self.schedule:
            for game in day:
                all_games[game["id"]] = game
        all_gameids = set(all_games.keys())
        completed_gameids = {
            os.path.splitext(os.path.basename(j))[0]
            for j in glob.glob(f"{self.tmpdir}/*")
        }
        todo_gameids = all_gameids - completed_gameids
        todo_games = {k: v for k, v in all_games.items() if k in todo_gameids}

        if self.test_mode == "":
            # Each thread will take game data as input, and dump out a json file
            pool = ThreadPool(threadpoolsize)
            threadholder = []
            for gameid, game in todo_games.items():
                print(
                    f"    Processing game {gameid} (season0={game['season']} day0={game['day']})"
                )
                args = [game, self.backend.fixed_ngenerations]
                threadholder.append(pool.apply_async(self.simulate_game, args=args))
            # Wait until pool is completely empty
            print("    Waiting for thread pool to close...")
            [t.wait() for t in threadholder]
            pool.close()
            pool.join()
            print("    Thread pool has been closed.")
            print(" *** Congratulations, the season is finished! *** ")

        elif self.test_mode == "fake":
            for gameid, game in todo_games.items():
                print(
                    f"    Processing game {gameid} (season0={game['season']} day0={game['day']})"
                )
                self.fake_simulate_game(game, self.backend.fixed_ngenerations)

        elif self.test_mode == "real":
            for gameid, game in todo_games.items():
                print(
                    f"    Processing game {gameid} (season0={game['season']} day0={game['day']})"
                )
                # kludge to prevent stuck in infinite loop
                game['patternName'] = 'random'
                self.simulate_game(game, self.backend.fixed_ngenerations)

        else:
            raise Exception(f"Error: could not determine mode from {self.test_mode}")

    def postseason_map(self, threadpoolsize=2):
        """
        Perform the map step of the postseason generation map-reduce.
        """
        pass

    def season_reduce(self, write=True):
        """
        Perform the reduce step of the season generation map-reduce.

        Determine whether all games in the schedule have been completed.
        If so, compute win/loss records, clean up games, and combined them
        into a single season.json file to be output.
        """
        pass

    def postseason_reduce(self, write=True):
        """
        Perform the reduce step of the postseason generation map-reduce.
        """
        pass










